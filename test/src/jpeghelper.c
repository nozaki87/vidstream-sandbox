#include <stdio.h>
#include <stdlib.h>
#include <memory.h>
#include <jpeglib.h>
#include <jerror.h>
 
typedef struct my_src_mgr my_src_mgr;
struct my_src_mgr
{
    struct jpeg_source_mgr pub;
    JOCTET eoi_buffer[2];
};
 
static void init_source(j_decompress_ptr cinfo)
{
}
 
static int fill_input_buffer(j_decompress_ptr cinfo)
{
    return 1;
}
 
static void skip_input_data(j_decompress_ptr cinfo, long num_bytes)
{
    my_src_mgr *src = (void *)cinfo->src;
    if (num_bytes > 0)
    {
        while (num_bytes > (long)src->pub.bytes_in_buffer)
        {
            num_bytes -= (long)src->pub.bytes_in_buffer;
            fill_input_buffer(cinfo);
        }
    }
    src->pub.next_input_byte += num_bytes;
    src->pub.bytes_in_buffer -= num_bytes;
}
 
static void term_source(j_decompress_ptr cinfo)
{
}
 
void jpeg_memory_src(j_decompress_ptr cinfo, unsigned char const *buffer, size_t bufsize)
{
    my_src_mgr *src;
    if (! cinfo->src)
    {
        cinfo->src = (*cinfo->mem->alloc_small)((void *)cinfo, JPOOL_PERMANENT, sizeof(my_src_mgr));;
    }
    src = (void *)cinfo->src;
    src->pub.init_source = init_source;
    src->pub.fill_input_buffer = fill_input_buffer;
    src->pub.skip_input_data = skip_input_data;
    src->pub.resync_to_restart = jpeg_resync_to_restart;
    src->pub.term_source = term_source;
    src->pub.next_input_byte = buffer;
    src->pub.bytes_in_buffer = bufsize;
}
 
static unsigned char  *load_jpg_helper(FILE *f, unsigned char *memory, int size)
{
    struct jpeg_decompress_struct cinfo;
    struct jpeg_error_mgr jerr;
    cinfo.err = jpeg_std_error(&jerr);
    jpeg_create_decompress(&cinfo);
    if (f)
    {
        jpeg_stdio_src(&cinfo, f);
    }
    else
    {
        jpeg_memory_src(&cinfo, memory, size);
    }
    jpeg_read_header(&cinfo, TRUE);
    jpeg_start_decompress(&cinfo);
    int w = cinfo.output_width;
    int h = cinfo.output_height;
    int s = cinfo.output_components;
    unsigned char  *bmp = malloc(w * h * 3);//create_bitmap_ex(24, w, h);
    unsigned char *buffer[1];
    unsigned char temp[w * s];
    buffer[0] = temp;
    unsigned char *p = bmp;
    while ((int)cinfo.output_scanline < h)
    {
        int j = cinfo.output_scanline;
        jpeg_read_scanlines(&cinfo, (void *)buffer, 1);
        if (s == 1)
        {
            int i;
            for (i = 0; i < w; i++)
            {
                unsigned char c = buffer[0][i];
                p[j * w * 3 + i * 3 + 0] = c;
                p[j * w * 3 + i * 3 + 1] = c;
                p[j * w * 3 + i * 3 + 2] = c;
            }
        }
        else if (s == 3)
        {
            int i;
            for (i = 0; i < w; i++)
            {
                unsigned char r = buffer[0][i * s + 0];
                unsigned char g = buffer[0][i * s + 1];
                unsigned char b = buffer[0][i * s + 2];
                p[j * w * 3 + i * 3 + 0] = b;
                p[j * w * 3 + i * 3 + 1] = g;
                p[j * w * 3 + i * 3 + 2] = r;
            }
        }
        else
        {
            fprintf(stderr, "Error! Cannot read JPEG data.\n");
            return NULL;
        }
    }
    jpeg_finish_decompress(&cinfo);
    jpeg_destroy_decompress(&cinfo);
    return bmp;
}
 
unsigned char  *load_jpg(char const *filename)
{
    FILE *f = fopen(filename, "rb");
    if (! f)
    {
        return NULL;
    }
    unsigned char  *bmp = load_jpg_helper(f, NULL, 0);
    fclose(f);
    return bmp;
}
 
unsigned char  *load_memory_jpg(unsigned char *memory, int size)
{
    return load_jpg_helper(NULL, (void *)memory, size);
}

unsigned char MJPGDHTSeg[0x1A4] =
{
/* JPEG DHT Segment for YCrCb omitted from MJPG data */
    0xFF, 0xC4, 0x01, 0xA2,
    0x00, 0x00, 0x01, 0x05, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x01, 0x00, 0x03, 0x01, 0x01, 0x01, 0x01,
    0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
    0x08, 0x09, 0x0A, 0x0B, 0x10, 0x00, 0x02, 0x01, 0x03, 0x03, 0x02, 0x04, 0x03, 0x05, 0x05, 0x04, 0x04, 0x00,
    0x00, 0x01, 0x7D, 0x01, 0x02, 0x03, 0x00, 0x04, 0x11, 0x05, 0x12, 0x21, 0x31, 0x41, 0x06, 0x13, 0x51, 0x61,
    0x07, 0x22, 0x71, 0x14, 0x32, 0x81, 0x91, 0xA1, 0x08, 0x23, 0x42, 0xB1, 0xC1, 0x15, 0x52, 0xD1, 0xF0, 0x24,
    0x33, 0x62, 0x72, 0x82, 0x09, 0x0A, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x34,
    0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x53, 0x54, 0x55, 0x56,
    0x57, 0x58, 0x59, 0x5A, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78,
    0x79, 0x7A, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8A, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99,
    0x9A, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7, 0xA8, 0xA9, 0xAA, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6, 0xB7, 0xB8, 0xB9,
    0xBA, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7, 0xD8, 0xD9,
    0xDA, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7,
    0xF8, 0xF9, 0xFA, 0x11, 0x00, 0x02, 0x01, 0x02, 0x04, 0x04, 0x03, 0x04, 0x07, 0x05, 0x04, 0x04, 0x00, 0x01,
    0x02, 0x77, 0x00, 0x01, 0x02, 0x03, 0x11, 0x04, 0x05, 0x21, 0x31, 0x06, 0x12, 0x41, 0x51, 0x07, 0x61, 0x71,
    0x13, 0x22, 0x32, 0x81, 0x08, 0x14, 0x42, 0x91, 0xA1, 0xB1, 0xC1, 0x09, 0x23, 0x33, 0x52, 0xF0, 0x15, 0x62,
    0x72, 0xD1, 0x0A, 0x16, 0x24, 0x34, 0xE1, 0x25, 0xF1, 0x17, 0x18, 0x19, 0x1A, 0x26, 0x27, 0x28, 0x29, 0x2A,
    0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x53, 0x54, 0x55, 0x56,
    0x57, 0x58, 0x59, 0x5A, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78,
    0x79, 0x7A, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8A, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98,
    0x99, 0x9A, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7, 0xA8, 0xA9, 0xAA, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6, 0xB7, 0xB8,
    0xB9, 0xBA, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7, 0xD8,
    0xD9, 0xDA, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8,
    0xF9, 0xFA
};

int mjpeg2jpeg(unsigned char * dst, const unsigned char * src, int srcsize)
{
    const unsigned char * srcp = src;
    char has_dht;
    int skip;
    if ((srcp[0] != 0xff) || (srcp[1] != 0xd8)) return 0;
    srcp += 2;
    has_dht = 0;
    while ((int)(srcp - src) >= srcsize) {
        if (srcp[0] != 0xff) return 0;
        if (srcp[1] == 0xc4) {
            has_dht = 1;
            break;
        } else if (srcp[1] == 0xda) {
            break;
        }
        skip = (srcp[2] << 8) + srcp[3];
        srcp += 4 + skip - 2;
    }
    if (!has_dht) {
        //printf("%x %x %d\n", (int)src, (int)srcp, (int)(srcp - src));
        memcpy(dst, src, (int)(srcp - src));
        dst += (int)(srcp - src);
        memcpy(dst, MJPGDHTSeg, 0x1A4);
        dst += 0x1A4;
        memcpy(dst, srcp, srcsize - (int)(srcp - src));
        return srcsize + 0x1A4;
    } else {
        memcpy(dst, src, srcsize);
        return srcsize;
    }
}

